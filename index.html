<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Moldura nas Fotos</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- exif-js para ler metadados -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
    <!-- JSZip CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- PWA meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
  </head>
  <body class="bg-neutral-100 min-h-screen flex flex-col items-center justify-center p-0">
    <!-- √çcone de configura√ß√µes fixo no topo direito -->
    <button id="settingsBtn" type="button" aria-label="Configura√ß√µes" class="fixed top-4 right-4 z-30 bg-white rounded-full p-2 shadow-md hover:bg-gray-100 focus:outline-none">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-7 h-7 text-gray-600">
        <path stroke-linecap="round" stroke-linejoin="round" d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.149.894c.07.424.384.764.78.93.398.164.855.142 1.205-.108l.737-.527a1.125 1.125 0 011.45.12l.773.774c.39.389.44 1.002.12 1.45l-.527.737c-.25.35-.272.806-.107 1.204.165.397.505.71.93.78l.893.15c.543.09.94.56.94 1.109v1.094c0 .55-.397 1.02-.94 1.11l-.893.149c-.425.07-.765.383-.93.78-.165.398-.143.854.107 1.204l.527.738c.32.447.269 1.06-.12 1.45l-.774.773a1.125 1.125 0 01-1.449.12l-.738-.527c-.447.32-1.06.269-1.45-.12l-.773-.774a1.125 1.125 0 01.12-1.45l.527-.737c.25-.35.273-.806.108-1.204-.165-.397-.505-.71-.93-.78l-.894-.149c-.542-.09-.94-.56-.94-1.11v-1.094c0-.55.398-1.019.94-1.11l.894-.149c.424-.071.765-.384.93-.78.165-.398.142-.854-.108-1.204l-.527-.738a1.125 1.125 0 01.12-1.45l.774-.773a1.125 1.125 0 011.45-.12l.737.527c.35.25.806.272 1.204.107.397-.165.71-.505.78-.929l.15-.894z" />
        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
    </button>
    <main class="w-full max-w-md bg-white rounded-none shadow-none p-0 flex flex-col gap-4 min-h-screen">
      <form id="uploadForm" class="flex flex-col gap-2 px-4 pt-8 pb-2">
        <label class="block">
          <input id="fileInput" type="file" accept="image/*" multiple class="mt-2 block w-full text-base text-gray-700 file:mr-4 file:py-3 file:px-4 file:rounded-xl file:border-0 file:text-base file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100" />
        </label>
        <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-xl transition text-base w-full">Adicionar Moldura</button>
        <button id="downloadZipBtn" class="hidden bg-gray-100 hover:bg-gray-200 text-indigo-700 font-bold py-3 px-4 rounded-xl transition text-base w-full border border-indigo-200 mt-2">Baixar todas em ZIP</button>
      </form>
      <div id="thumbsGrid" class="hidden grid grid-cols-2 gap-4 px-4 mt-4"></div>
      <div id="previewArea" class="hidden flex-col items-center gap-4 px-4">
        <canvas id="canvasPreview" width="400" height="400" class="rounded-xl shadow-lg border-4 border-indigo-400"></canvas>
        <div id="exifInfo" class="text-xs text-gray-600 text-center"></div>
        <button id="downloadBtn" class="mt-2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition">Baixar Foto com Moldura</button>
      </div>
    </main>
    <!-- Painel de configura√ß√µes oculto por padr√£o -->
    <div id="settingsPanel" class="hidden fixed top-0 left-0 w-full h-full z-20 flex items-start justify-center bg-black bg-opacity-30">
      <div class="bg-white border border-gray-200 rounded-xl px-6 py-5 mt-16 shadow-xl flex flex-col gap-3 w-full max-w-xs relative animate-fadeIn">
        <button id="closeSettings" type="button" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600" aria-label="Fechar"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></button>
        <span class="text-xs font-semibold text-gray-500 tracking-wide mb-1">Configura√ß√µes</span>
        <div class="flex flex-row gap-4 items-center">
          <label class="flex items-center gap-2 text-sm font-medium text-gray-700">
            <input type="radio" name="outputRatio" value="1:1" checked class="accent-indigo-600" />
            Quadrado 1:1
          </label>
          <label class="flex items-center gap-2 text-sm font-medium text-gray-700">
            <input type="radio" name="outputRatio" value="9:16" class="accent-indigo-600" />
            Stories 9:16
          </label>
        </div>
        <label class="flex items-center gap-2 text-sm font-medium text-gray-700 mt-1">
          <input type="checkbox" id="leicaBW" class="accent-indigo-600" />
          Preto e branco estilo Leica
        </label>
        <label class="flex items-center gap-2 text-sm font-medium text-gray-700 mt-1">
          <input type="checkbox" id="daidoMoriyama" class="accent-indigo-600" />
          Daido Moriyama
        </label>
        <label class="flex items-center gap-2 text-sm font-medium text-gray-700 mt-1">
          <input type="checkbox" id="ultraDaido" class="accent-indigo-600" />
          Modo Ultra Daido
        </label>
        <label class="flex items-center gap-2 text-sm font-medium text-gray-700 mt-1">
          <input type="checkbox" id="leicaQ3Color" class="accent-indigo-600" />
          Leica Q3 Color
        </label>
      </div>
    </div>
    <!-- Overlay para visualiza√ß√£o em tela cheia -->
    <div id="imageOverlay" class="fixed inset-0 bg-black bg-opacity-90 flex-col items-center justify-center z-50 hidden">
      <img id="overlayImg" src="" alt="Imagem em tela cheia" class="max-w-full max-h-[80vh] rounded-xl shadow-lg mx-auto mt-20" />
      <p class="text-white text-center mt-4 text-base font-medium">Toque e segure a imagem para salvar</p>
      <button id="closeOverlayBtn" class="mt-6 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-6 rounded-lg transition mx-auto block">Fechar</button>
    </div>
    <footer class="mt-6 text-gray-400 text-xs text-center pb-2">Feito com ‚ù§Ô∏è por Gabriel Sicuro</footer>

    <script>
      // Porcentagem do lado ocupado pela foto
      const IMG_RATIO = 0.9;
      const PREVIEW_SIZE = 400;

      const uploadForm = document.getElementById('uploadForm');
      const fileInput = document.getElementById('fileInput');
      const previewArea = document.getElementById('previewArea');
      const canvasPreview = document.getElementById('canvasPreview');
      const ctxPreview = canvasPreview.getContext('2d');
      const downloadBtn = document.getElementById('downloadBtn');
      const exifInfoDiv = document.getElementById('exifInfo');
      const thumbsGrid = document.getElementById('thumbsGrid');

      let imgOriginal = null;
      let finalImageReady = false;
      let exifText = '';

      // Fun√ß√£o para montar texto das infos EXIF com tracinhos estilo Flickr
      function getExifText(tags) {
        const parts = [];
        // Marca + modelo
        if (tags.Make || tags.Model) parts.push((tags.Make||'') + ' ' + (tags.Model||''));
        // Dist√¢ncia focal
        if (tags.FocalLength) parts.push(tags.FocalLength + 'mm');
        // f/N√∫mero
        if (tags.FNumber) parts.push('f/' + tags.FNumber);
        // ISO
        if (tags.ISOSpeedRatings) parts.push('ISO ' + tags.ISOSpeedRatings);
        return parts.join(' ‚Äî ');
      }

      // Fun√ß√£o para montar HTML das infos EXIF com √≠cones estilo Flickr
      function getExifHtml(tags) {
        const parts = [];
        // Marca + modelo
        if (tags.Make || tags.Model) parts.push('<span class="exif-icon">üì∑</span> ' + (tags.Make||'') + ' ' + (tags.Model||''));
        // Dist√¢ncia focal
        if (tags.FocalLength) parts.push('<span class="exif-icon">üî≠</span> ' + tags.FocalLength + 'mm');
        // f/N√∫mero
        if (tags.FNumber) parts.push('<span class="exif-icon">üåô</span> f/' + tags.FNumber);
        // Tempo de exposi√ß√£o
        if (tags.ExposureTime) {
          let exp = tags.ExposureTime;
          if (typeof exp === 'number') {
            exp = exp >= 1 ? exp.toFixed(1) + 's' : ('1/' + Math.round(1/exp) + 's');
          } else if (typeof exp === 'string' && exp.indexOf('/') > -1) {
            exp = exp + 's';
          }
          parts.push('<span class="exif-icon">‚è±Ô∏è</span> ' + exp);
        }
        // ISO
        if (tags.ISOSpeedRatings) parts.push('<span class="exif-icon">üåÄ</span> ISO ' + tags.ISOSpeedRatings);
        return parts.join(' &nbsp;&nbsp;&nbsp; '); // Espa√ßo extra entre infos
      }

      // NOVO: Multi-foto e thumbs
      fileInput.addEventListener('change', function (e) {
        const files = Array.from(fileInput.files);
        thumbsGrid.innerHTML = '';
        if (files.length === 0) {
          thumbsGrid.classList.add('hidden');
          document.getElementById('downloadZipBtn').classList.add('hidden');
          return;
        }
        thumbsGrid.classList.remove('hidden');
        document.getElementById('downloadZipBtn').classList.remove('hidden');
        // Armazenar infos de cada imagem
        window._zipImages = [];
        window._thumbSources = [];
        files.forEach((file, idx) => {
          const reader = new FileReader();
          reader.onload = function (evt) {
            const img = new Image();
            img.onload = function () {
              // Cria thumb canvas
              const thumbCanvas = document.createElement('canvas');
              thumbCanvas.width = 160;
              thumbCanvas.height = 160;
              const thumbCtx = thumbCanvas.getContext('2d');
              thumbCtx.fillStyle = '#fff';
              thumbCtx.fillRect(0, 0, 160, 160);
              let tw, th;
              if (img.width > img.height) {
                tw = 144;
                th = (img.height / img.width) * 144;
              } else {
                th = 144;
                tw = (img.width / img.height) * 144;
              }
              thumbCtx.drawImage(img, (160-tw)/2, (160-th)/2, tw, th);
              // Salva o src da imagem original para reprocessar depois
              window._thumbSources[idx] = evt.target.result;
              // Aplica filtro Daido Moriyama, se selecionado
              const daidoCheckbox = document.getElementById('daidoMoriyama');
              const leicaCheckbox = document.getElementById('leicaBW');
              const ultraDaidoCheckbox = document.getElementById('ultraDaido');
              const leicaQ3ColorCheckbox = document.getElementById('leicaQ3Color');
              renderThumb(img, thumbCanvas, leicaCheckbox && leicaCheckbox.checked, daidoCheckbox && daidoCheckbox.checked, ultraDaidoCheckbox && ultraDaidoCheckbox.checked, leicaQ3ColorCheckbox && leicaQ3ColorCheckbox.checked);
              // Container da thumb
              const thumbDiv = document.createElement('div');
              thumbDiv.className = 'flex flex-col items-center bg-gray-50 rounded-xl shadow p-2 cursor-pointer hover:ring-4 hover:ring-blue-400 transition relative';
              thumbDiv.appendChild(thumbCanvas);

              // Bot√£o remover (X)
              const removeBtn = document.createElement('button');
              removeBtn.type = 'button';
              removeBtn.title = 'Remover foto';
              removeBtn.innerHTML = '&times;';
              removeBtn.className = 'absolute top-1 right-2 text-xl text-gray-400 hover:text-red-500 font-bold bg-white bg-opacity-80 rounded-full w-7 h-7 flex items-center justify-center shadow-sm z-10';
              thumbDiv.appendChild(removeBtn);

              // Bot√£o de refresh do Daido Moriyama
              const refreshBtn = document.createElement('button');
              refreshBtn.type = 'button';
              refreshBtn.title = 'Novo Daido Moriyama';
              refreshBtn.innerHTML = 'üîÑ';
              refreshBtn.className = 'absolute top-1 left-2 text-lg text-gray-400 hover:text-blue-600 font-bold bg-white bg-opacity-80 rounded-full w-7 h-7 flex items-center justify-center shadow-sm z-10';
              refreshBtn.style.display = (daidoCheckbox && daidoCheckbox.checked) ? '' : 'none';
              thumbDiv.appendChild(refreshBtn);

              // Atualiza visibilidade do bot√£o de refresh ao mudar o filtro Daido Moriyama
              daidoCheckbox && daidoCheckbox.addEventListener('change', function() {
                refreshBtn.style.display = this.checked ? '' : 'none';
              });

              // Ao clicar no refresh, redesenha s√≥ a thumb com novo Daido Moriyama
              refreshBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                renderThumb(img, thumbCanvas, leicaCheckbox && leicaCheckbox.checked, daidoCheckbox && daidoCheckbox.checked, ultraDaidoCheckbox && ultraDaidoCheckbox.checked, leicaQ3ColorCheckbox && leicaQ3ColorCheckbox.checked);
              });

              // Checkbox para mostrar infos
              const infoToggle = document.createElement('input');
              infoToggle.type = 'checkbox';
              infoToggle.id = 'infoToggle'+idx;
              infoToggle.className = 'mt-2';
              const infoLabel = document.createElement('label');
              infoLabel.htmlFor = infoToggle.id;
              infoLabel.innerText = 'Exibir infos';
              infoLabel.className = 'ml-2 text-xs text-gray-600';

              // Div para infos
              const infoDiv = document.createElement('div');
              infoDiv.className = 'text-xs text-gray-600 text-center mt-1 hidden';
              thumbDiv.appendChild(infoToggle);
              thumbDiv.appendChild(infoLabel);
              thumbDiv.appendChild(infoDiv);

              // Bot√£o de download individual
              const downloadThumbBtn = document.createElement('button');
              downloadThumbBtn.type = 'button';
              downloadThumbBtn.innerText = 'Baixar';
              downloadThumbBtn.className = 'mt-2 bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-lg text-xs transition';
              thumbDiv.appendChild(downloadThumbBtn);

              let exifForThis = '';
              infoToggle.addEventListener('change', function() {
                if (infoToggle.checked) {
                  EXIF.getData(file, function () {
                    const allExif = EXIF.getAllTags(this);
                    exifForThis = getExifText(allExif);
                    infoDiv.textContent = exifForThis || 'Sem informa√ß√µes.';
                    infoDiv.classList.remove('hidden');
                  });
                } else {
                  infoDiv.classList.add('hidden');
                  exifForThis = '';
                }
              });

              // Salva canvas para overlay (Daido Moriyama e normal)
              function getDaidoMoriyamaDataUrl() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 400;
                tempCanvas.height = 400;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.fillStyle = '#fff';
                tempCtx.fillRect(0, 0, 400, 400);
                let tw, th;
                if (img.width > img.height) {
                  tw = 360;
                  th = (img.height / img.width) * 360;
                } else {
                  th = 360;
                  tw = (img.width / img.height) * 360;
                }
                tempCtx.drawImage(img, (400-tw)/2, (400-th)/2, tw, th);
                applyDaidoMoriyamaFilter(tempCtx, (400-tw)/2, (400-th)/2, tw, th, ultraDaidoCheckbox && ultraDaidoCheckbox.checked);
                return tempCanvas.toDataURL('image/png');
              }
              function getOriginalDataUrl() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 400;
                tempCanvas.height = 400;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.fillStyle = '#fff';
                tempCtx.fillRect(0, 0, 400, 400);
                let tw, th;
                if (img.width > img.height) {
                  tw = 360;
                  th = (img.height / img.width) * 360;
                } else {
                  th = 360;
                  tw = (img.width / img.height) * 360;
                }
                tempCtx.drawImage(img, (400-tw)/2, (400-th)/2, tw, th);
                return tempCanvas.toDataURL('image/png');
              }
              // Ao clicar na thumb, mostra overlay com Daido Moriyama ou n√£o
              thumbCanvas.addEventListener('click', function() {
                const leicaAtivo = document.getElementById('leicaBW')?.checked;
                const daidoAtivo = document.getElementById('daidoMoriyama')?.checked;
                const ultraDaidoAtivo = document.getElementById('ultraDaido')?.checked;
                const leicaQ3ColorAtivo = document.getElementById('leicaQ3Color')?.checked;
                const overlay = document.getElementById('imageOverlay');
                const overlayImg = document.getElementById('overlayImg');
                const tempCanvas = document.createElement('canvas');
                EXIF.getData(file, function () {
                  const allExif = EXIF.getAllTags(this);
                  // S√≥ exibe infos se o infoToggle estiver marcado
                  const exifForThis = (infoToggle && infoToggle.checked) ? getExifText(allExif) : '';
                  renderOverlay(img, tempCanvas, leicaAtivo, daidoAtivo, exifForThis, ultraDaidoAtivo, leicaQ3ColorAtivo);
                  overlayImg.src = tempCanvas.toDataURL('image/png');
                  overlay.classList.remove('hidden');
                  overlay.classList.add('flex');
                });
              });

              // Download individual corrigido
              downloadThumbBtn.addEventListener('click', function(ev) {
                ev.stopPropagation();
                if (infoToggle.checked) {
                  EXIF.getData(file, function () {
                    const allExif = EXIF.getAllTags(this);
                    const exifForThis = getExifText(allExif);
                    const url = generateCanvasUrl(img, infoToggle, exifForThis, idx);
                    const link = document.createElement('a');
                    link.download = `foto-moldurada-1x1-${idx+1}.png`;
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    setTimeout(() => document.body.removeChild(link), 100);
                  });
                } else {
                  const url = generateCanvasUrl(img, infoToggle, '', idx);
                  const link = document.createElement('a');
                  link.download = `foto-moldurada-1x1-${idx+1}.png`;
                  link.href = url;
                  document.body.appendChild(link);
                  link.click();
                  setTimeout(() => document.body.removeChild(link), 100);
                }
              });

              // Remover thumb e atualizar lista
              removeBtn.addEventListener('click', function(ev) {
                ev.stopPropagation();
                thumbDiv.remove();
                window._zipImages[idx] = null;
                // Se n√£o houver mais thumbs, esconde grid e bot√£o ZIP
                if (!Array.from(thumbsGrid.children).some(child => child.style.display !== 'none')) {
                  thumbsGrid.classList.add('hidden');
                  document.getElementById('downloadZipBtn').classList.add('hidden');
                }
              });

              // Salvar fun√ß√£o para gerar imagem final (com infos) para o ZIP
              window._zipImages[idx] = () => {
                return new Promise((resolve) => {
                  if (infoToggle.checked) {
                    EXIF.getData(file, function () {
                      const allExif = EXIF.getAllTags(this);
                      const exifForThis = getExifText(allExif);
                      resolve(generateCanvasUrl(img, infoToggle, exifForThis, idx));
                    });
                  } else {
                    resolve(generateCanvasUrl(img, infoToggle, '', idx));
                  }
                });
              };
              thumbsGrid.appendChild(thumbDiv);
            };
            img.src = evt.target.result;
          };
          reader.readAsDataURL(file);
        });
      });

      // Fun√ß√£o para gerar imagem final para o ZIP
      function generateCanvasUrl(img, infoToggle, exifForThis, idx) {
        // Descobre o formato escolhido
        let ratio = 1;
        let canvasW, canvasH;
        const selected = document.querySelector('input[name="outputRatio"]:checked');
        if (selected && selected.value === '9:16') {
          ratio = 9/16;
          canvasH = 1600;
          canvasW = Math.round(canvasH * ratio);
        } else {
          canvasW = canvasH = 1200;
        }
        // Foto ocupa no m√°ximo 90% do lado menor (moldura de 5% cada lado)
        const maxFoto = Math.min(canvasW, canvasH) * 0.9;
        let drawW = img.width, drawH = img.height;
        const scale = Math.min(maxFoto / img.width, maxFoto / img.height);
        drawW = img.width * scale;
        drawH = img.height * scale;
        const x = (canvasW - drawW) / 2;
        const y = (canvasH - drawH) / 2;
        const canvas = document.createElement('canvas');
        canvas.width = canvasW;
        canvas.height = canvasH;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvasW, canvasH);
        ctx.drawImage(img, x, y, drawW, drawH);
        // Filtro preto e branco estilo Leica
        const leicaBW = document.getElementById('leicaBW')?.checked;
        if (leicaBW) {
          applyLeicaFilter(ctx, x, y, drawW, drawH);
        }
        // Filtro Daido Moriyama
        const daidoMoriyama = document.getElementById('daidoMoriyama')?.checked;
        const ultraDaido = document.getElementById('ultraDaido')?.checked;
        if (daidoMoriyama) {
          applyDaidoMoriyamaFilter(ctx, x, y, drawW, drawH, ultraDaido);
        }
        // Filtro Leica Q3 Color
        const leicaQ3Color = document.getElementById('leicaQ3Color')?.checked;
        if (leicaQ3Color) {
          applyLeicaQ3ColorFilter(ctx, x, y, drawW, drawH);
        }
        // Infos
        if (infoToggle && infoToggle.checked && exifForThis) {
          ctx.save();
          let maxFont = Math.round(canvasH * 0.03);
          let fontSize = maxFont;
          ctx.font = fontSize + 'px sans-serif';
          ctx.fillStyle = '#444';
          ctx.textAlign = 'center';
          let fits = false;
          if (img.height > img.width * 1.25) {
            ctx.save();
            ctx.translate(canvasW * 0.04, canvasH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            while (fontSize > 10) {
              ctx.font = fontSize + 'px sans-serif';
              if (ctx.measureText(exifForThis).width < canvasH * 0.9) { fits = true; break; }
              fontSize -= 1;
            }
            ctx.font = fontSize + 'px sans-serif';
            ctx.fillText(exifForThis, 0, 0);
            ctx.restore();
          } else {
            let yInfo = canvasH - canvasH * 0.15;
            if (canvasW === canvasH) {
              yInfo = canvasH - canvasH * 0.03;
            }
            while (fontSize > 10) {
              ctx.font = fontSize + 'px sans-serif';
              if (ctx.measureText(exifForThis).width < canvasW * 0.9) { fits = true; break; }
              fontSize -= 1;
            }
            ctx.font = fontSize + 'px sans-serif';
            ctx.fillText(exifForThis, canvasW / 2, yInfo);
          }
          ctx.restore();
        }
        return canvas.toDataURL('image/png');
      }

      // Filtro Daido Moriyama ultra fiel √†s refer√™ncias
      function applyDaidoMoriyamaFilter(ctx, x, y, w, h, ultra) {
        // 1. PB extremo + granula√ß√£o procedural (gr√£os grandes e pequenos)
        const imgData = ctx.getImageData(x, y, w, h);
        let data = imgData.data;
        for (let j = 0; j < h; j++) {
          for (let i = 0; i < w; i++) {
            let idx = (j*w + i)*4;
            let avg = 0.299*data[idx] + 0.587*data[idx+1] + 0.114*data[idx+2];
            // Granula√ß√£o procedural: mistura ru√≠do pixel a pixel e "gr√£os" maiores
            let grain = (Math.random()-0.5)*110 + (Math.random()-0.5)*80*Math.sin(i/8+j/11);
            avg += grain;
            // Threshold PB extremo
            let val = avg > 90 ? 255 : 0;
            // Manchas brancas e pretas
            if (Math.random()<0.006 && val===255) val = 255;
            if (Math.random()<0.006 && val===0) val = 0;
            data[idx] = data[idx+1] = data[idx+2] = val;
          }
        }
        ctx.putImageData(imgData, x, y);
        // 1b. Contraste local (clarity/unsharp mask)
        let sharpData = ctx.getImageData(x, y, w, h);
        let sd = sharpData.data;
        let blurred = new Uint8ClampedArray(sd.length);
        // Simples blur box 3x3
        for (let j = 1; j < h-1; j++) {
          for (let i = 1; i < w-1; i++) {
            let idx = (j*w + i)*4;
            let sum = 0;
            for (let dj = -1; dj <= 1; dj++) {
              for (let di = -1; di <= 1; di++) {
                let nidx = ((j+dj)*w + (i+di))*4;
                sum += sd[nidx];
              }
            }
            blurred[idx] = blurred[idx+1] = blurred[idx+2] = sum/9;
            blurred[idx+3] = 255;
          }
        }
        // Unsharp mask: original + (original-blur)*amount
        let amount = ultra ? 1.2 + Math.random()*0.5 : 0.7 + Math.random()*0.3; // ultra: mais forte
        for (let i = 0; i < sd.length; i+=4) {
          let orig = sd[i];
          let blur = blurred[i];
          let val = orig + (orig-blur)*amount;
          val = Math.max(0, Math.min(255, val));
          sd[i] = sd[i+1] = sd[i+2] = val;
        }
        ctx.putImageData(sharpData, x, y);
        // 1c. Fade nos pretos (levanta o preto)
        let fadeData = ctx.getImageData(x, y, w, h);
        let fd = fadeData.data;
        for (let i = 0; i < fd.length; i+=4) {
          let v = fd[i];
          // curva para levantar o preto
          v = ultra ? v*0.90 + 32 : v*0.92 + 22;
          fd[i] = fd[i+1] = fd[i+2] = Math.max(0, Math.min(255, v));
        }
        ctx.putImageData(fadeData, x, y);
        // 2. Distor√ß√£o org√¢nica (marbling/ondas)
        const distortData = ctx.getImageData(x, y, w, h);
        let d = distortData.data;
        let temp = new Uint8ClampedArray(d.length);
        // Par√¢metros para suavizar e randomizar a onda
        let maxOffset = ultra ? 12 : 7; // menor intensidade padr√£o
        for (let j = 0; j < h; j++) {
          // Mais suave no centro, mais forte nas bordas
          let distFromCenter = Math.abs(j - h/2) / (h/2);
          let edgeBoost = 0.7 + 0.6 * distFromCenter; // mais forte nas bordas
          // Randomiza√ß√£o extra
          let randomFactor = (Math.random()-0.5)*2;
          // Offset menos regular, mistura seno, cosseno e ru√≠do
          let offset = Math.floor(
            Math.sin(j/18 + randomFactor)*maxOffset*0.7*edgeBoost +
            Math.cos(j/7 + randomFactor*2)*maxOffset*0.3*edgeBoost +
            (Math.random()-0.5)*maxOffset*0.4*edgeBoost
          );
          for (let i = 0; i < w; i++) {
            let srcI = i+offset;
            if (srcI<0 || srcI>=w) continue;
            let idx = (j*w + i)*4;
            let srcIdx = (j*w + srcI)*4;
            temp[idx] = d[srcIdx];
            temp[idx+1] = d[srcIdx+1];
            temp[idx+2] = d[srcIdx+2];
            temp[idx+3] = d[srcIdx+3];
          }
        }
        for (let i = 0; i < temp.length; i++) d[i] = temp[i];
        ctx.putImageData(distortData, x, y);
        // 3. Blur direcional (arrasto/motion blur)
        const blurData = ctx.getImageData(x, y, w, h);
        let bd = blurData.data;
        // Simula arrasto horizontal
        for (let j = 0; j < h; j++) {
          for (let i = 1; i < w; i++) {
            let idx = (j*w + i)*4;
            let prevIdx = (j*w + i-1)*4;
            bd[idx] = (bd[idx]*0.6 + bd[prevIdx]*0.4);
            bd[idx+1] = (bd[idx+1]*0.6 + bd[prevIdx+1]*0.4);
            bd[idx+2] = (bd[idx+2]*0.6 + bd[prevIdx+2]*0.4);
          }
        }
        ctx.putImageData(blurData, x, y);
        // 4. Vinheta pesada
        let vignette = ctx.getImageData(x, y, w, h);
        let vd = vignette.data;
        let cx = w/2, cy = h/2, maxR = Math.sqrt(cx*cx+cy*cy);
        for (let j = 0; j < h; j++) {
          for (let i = 0; i < w; i++) {
            let idx = (j*w + i)*4;
            let dx = i-cx, dy = j-cy;
            let dist = Math.sqrt(dx*dx+dy*dy)/maxR;
            let darken = 1-Math.pow(1-dist,2)*0.8;
            vd[idx] = vd[idx+1] = vd[idx+2] = vd[idx]*darken;
          }
        }
        ctx.putImageData(vignette, x, y);
      }

      // Filtro preto e branco estilo Leica
      function applyLeicaFilter(ctx, x, y, w, h) {
        // 1. PB cl√°ssico com contraste suave
        const imgData = ctx.getImageData(x, y, w, h);
        let data = imgData.data;
        for (let j = 0; j < h; j++) {
          for (let i = 0; i < w; i++) {
            let idx = (j*w + i)*4;
            // Convers√£o para PB (luminosidade)
            let lum = 0.299*data[idx] + 0.587*data[idx+1] + 0.114*data[idx+2];
            // Suave curva S para contraste Leica
            lum = lum/255;
            lum = 0.85 * (lum < 0.5 ? 2*lum*lum : 1 - 2*(1-lum)*(1-lum)) + 0.15*lum; // curva S leve
            lum = Math.max(0, Math.min(1, lum));
            lum = 255*lum;
            data[idx] = data[idx+1] = data[idx+2] = lum;
          }
        }
        ctx.putImageData(imgData, x, y);
        // 2. Vinheta leve
        let vignette = ctx.getImageData(x, y, w, h);
        let vd = vignette.data;
        let cx = w/2, cy = h/2, maxR = Math.sqrt(cx*cx+cy*cy);
        for (let j = 0; j < h; j++) {
          for (let i = 0; i < w; i++) {
            let idx = (j*w + i)*4;
            let dx = i-cx, dy = j-cy;
            let dist = Math.sqrt(dx*dx+dy*dy)/maxR;
            let darken = 1-Math.pow(1-dist,2)*0.3; // vinheta leve
            vd[idx] = vd[idx+1] = vd[idx+2] = vd[idx]*darken;
          }
        }
        ctx.putImageData(vignette, x, y);
      }

      // Filtro Leica Q3 Color (contraste moderado, cores vibrantes/naturais, realce suave, vinheta e leve granula√ß√£o)
      function applyLeicaQ3ColorFilter(ctx, x, y, w, h) {
        // 1. Ajuste de contraste e curvas de cor
        const imgData = ctx.getImageData(x, y, w, h);
        let data = imgData.data;
        for (let j = 0; j < h; j++) {
          for (let i = 0; i < w; i++) {
            let idx = (j*w + i)*4;
            // Realce suave
            for (let c = 0; c < 3; c++) {
              let val = data[idx+c]/255;
              // Curva S suave
              val = 0.8 * (val < 0.5 ? 2*val*val : 1 - 2*(1-val)*(1-val)) + 0.2*val;
              // Leve boost de satura√ß√£o para tons quentes
              if (c === 0) val *= 1.04; // R
              if (c === 1) val *= 1.05; // G
              if (c === 2) val *= 1.01; // B
              data[idx+c] = Math.max(0, Math.min(255, val*255));
            }
            // Leve granula√ß√£o (ru√≠do sutil)
            let grain = (Math.random()-0.5)*10;
            data[idx]   = Math.max(0, Math.min(255, data[idx]  + grain));
            data[idx+1] = Math.max(0, Math.min(255, data[idx+1]+ grain));
            data[idx+2] = Math.max(0, Math.min(255, data[idx+2]+ grain));
          }
        }
        ctx.putImageData(imgData, x, y);
        // 2. Vinheta leve
        let vignette = ctx.getImageData(x, y, w, h);
        let vd = vignette.data;
        let cx = w/2, cy = h/2, maxR = Math.sqrt(cx*cx+cy*cy);
        for (let j = 0; j < h; j++) {
          for (let i = 0; i < w; i++) {
            let idx = (j*w + i)*4;
            let dx = i-cx, dy = j-cy;
            let dist = Math.sqrt(dx*dx+dy*dy)/maxR;
            let darken = 1-Math.pow(1-dist,2)*0.18; // vinheta leve
            vd[idx]   = vd[idx]  * darken;
            vd[idx+1] = vd[idx+1]* darken;
            vd[idx+2] = vd[idx+2]* darken;
          }
        }
        ctx.putImageData(vignette, x, y);
      }

      // Redesenha a thumb conforme filtros
      function renderThumb(img, canvas, leica, daido, ultra, leicaQ3Color) {
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        let tw, th;
        if (img.width > img.height) {
          tw = 144;
          th = (img.height / img.width) * 144;
        } else {
          th = 144;
          tw = (img.width / img.height) * 144;
        }
        const px = (160-tw)/2, py = (160-th)/2;
        ctx.drawImage(img, px, py, tw, th);
        if (leica) applyLeicaFilter(ctx, px, py, tw, th);
        if (daido) applyDaidoMoriyamaFilter(ctx, px, py, tw, th, ultra);
        if (leicaQ3Color) applyLeicaQ3ColorFilter(ctx, px, py, tw, th);
      }

      // Redesenha overlay conforme filtros, agora respeitando o modo Stories
      function renderOverlay(img, canvas, leica, daido, exifText, ultra, leicaQ3Color) {
        // Detecta ratio selecionado
        let ratio = 1;
        let canvasW, canvasH;
        const selected = document.querySelector('input[name="outputRatio"]:checked');
        if (selected && selected.value === '9:16') {
          ratio = 9/16;
          canvasH = 1600;
          canvasW = Math.round(canvasH * ratio);
        } else {
          canvasW = canvasH = 1200;
        }
        canvas.width = canvasW;
        canvas.height = canvasH;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvasW, canvasH);
        // Foto ocupa no m√°ximo 90% do lado menor (moldura de 5% cada lado)
        const maxFoto = Math.min(canvasW, canvasH) * 0.9;
        let drawW = img.width, drawH = img.height;
        const scale = Math.min(maxFoto / img.width, maxFoto / img.height);
        drawW = img.width * scale;
        drawH = img.height * scale;
        const x = (canvasW - drawW) / 2;
        const y = (canvasH - drawH) / 2;
        ctx.drawImage(img, x, y, drawW, drawH);
        if (leica) applyLeicaFilter(ctx, x, y, drawW, drawH);
        if (daido) applyDaidoMoriyamaFilter(ctx, x, y, drawW, drawH, ultra);
        if (leicaQ3Color) applyLeicaQ3ColorFilter(ctx, x, y, drawW, drawH);
        // Desenha info EXIF se existir
        if (exifText) {
          ctx.save();
          let fontSize = Math.round(canvasH * 0.018); // fonte bem sutil
          ctx.font = fontSize + 'px sans-serif';
          ctx.fillStyle = 'rgba(50,50,50,0.38)'; // cor sutil
          ctx.textAlign = 'center';
          let yInfo = canvasH - canvasH * 0.02; // padr√£o
          if (canvasW / canvasH < 0.8) { // Stories (9:16)
            yInfo = canvasH - canvasH * 0.13;
          }
          ctx.fillText(exifText, canvasW / 2, yInfo);
          ctx.restore();
        }
      }

      // Fecha overlay ao clicar no bot√£o ou fora da imagem
      document.getElementById('closeOverlayBtn').addEventListener('click', function() {
        const overlay = document.getElementById('imageOverlay');
        overlay.classList.add('hidden');
        overlay.classList.remove('flex');
        document.getElementById('overlayImg').src = '';
      });
      document.getElementById('imageOverlay').addEventListener('click', function(e) {
        if (e.target === this) {
          this.classList.add('hidden');
          this.classList.remove('flex');
          document.getElementById('overlayImg').src = '';
        }
      });

      // Mant√©m funcionalidade de preview e download para uma foto selecionada
      uploadForm.addEventListener('submit', function (e) {
        e.preventDefault();
        const file = fileInput.files[0];
        if (!file) return;
        exifText = '';
        exifInfoDiv.textContent = '';
        EXIF.getData(file, function () {
          const allExif = EXIF.getAllTags(this);
          exifText = getExifText(allExif);
        });
        const reader = new FileReader();
        reader.onload = function (evt) {
          const img = new Image();
          img.onload = function () {
            imgOriginal = img;
            const previewQuad = PREVIEW_SIZE;
            const targetSize = previewQuad * IMG_RATIO;
            let drawWidth, drawHeight;
            if (img.width > img.height) {
              drawWidth = targetSize;
              drawHeight = (img.height / img.width) * targetSize;
            } else {
              drawHeight = targetSize;
              drawWidth = (img.width / img.height) * targetSize;
            }
            ctxPreview.clearRect(0, 0, PREVIEW_SIZE, PREVIEW_SIZE);
            ctxPreview.fillStyle = '#fff';
            ctxPreview.fillRect(0, 0, PREVIEW_SIZE, PREVIEW_SIZE);
            ctxPreview.drawImage(img, (PREVIEW_SIZE-drawWidth)/2, (PREVIEW_SIZE-drawHeight)/2, drawWidth, drawHeight);
            previewArea.classList.remove('hidden');
            finalImageReady = true;
          };
          img.src = evt.target.result;
        };
        reader.readAsDataURL(file);
      });

      downloadBtn.addEventListener('click', function () {
        if (!finalImageReady || !imgOriginal) return;
        const maxSide = Math.max(imgOriginal.width, imgOriginal.height);
        const quadSize = Math.round(maxSide / IMG_RATIO);
        const canvas = document.createElement('canvas');
        canvas.width = quadSize;
        canvas.height = quadSize;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, quadSize, quadSize);
        let drawWidth, drawHeight;
        if (imgOriginal.width > imgOriginal.height) {
          drawWidth = quadSize * IMG_RATIO;
          drawHeight = (imgOriginal.height / imgOriginal.width) * drawWidth;
        } else {
          drawHeight = quadSize * IMG_RATIO;
          drawWidth = (imgOriginal.width / imgOriginal.height) * drawHeight;
        }
        const x = (quadSize - drawWidth) / 2;
        const y = (quadSize - drawHeight) / 2;
        ctx.drawImage(imgOriginal, x, y, drawWidth, drawHeight);
        if (exifText) {
          ctx.font = Math.round(quadSize * 0.03) + 'px sans-serif';
          ctx.fillStyle = '#444';
          ctx.textAlign = 'center';
          ctx.fillText(exifText, quadSize / 2, quadSize - quadSize * 0.03);
        }
        const link = document.createElement('a');
        link.download = 'foto-moldurada-1x1.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      });

      // Baixar todas em ZIP
      document.getElementById('downloadZipBtn').addEventListener('click', async function() {
        if (!window._zipImages || window._zipImages.length === 0) return;
        const zip = new JSZip();
        for (let i = 0; i < window._zipImages.length; i++) {
          if (typeof window._zipImages[i] === 'function') {
            const dataUrl = await window._zipImages[i]();
            // Converte para blob
            const base64 = dataUrl.split(',')[1];
            zip.file(`foto-moldurada-1x1-${i+1}.png`, base64, {base64: true});
          }
        }
        const content = await zip.generateAsync({type: 'blob'});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'fotos-molduradas.zip';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
      });

      // Abrir e fechar painel de configura√ß√µes
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsPanel = document.getElementById('settingsPanel');
      const closeSettings = document.getElementById('closeSettings');
      if (settingsBtn && settingsPanel) {
        settingsBtn.addEventListener('click', () => {
          settingsPanel.classList.remove('hidden');
        });
      }
      if (closeSettings && settingsPanel) {
        closeSettings.addEventListener('click', () => {
          settingsPanel.classList.add('hidden');
        });
      }
      // Fecha ao clicar fora do painel
      if (settingsPanel) {
        settingsPanel.addEventListener('click', (e) => {
          if (e.target === settingsPanel) settingsPanel.classList.add('hidden');
        });
      }

      // Registro do service worker para PWA offline
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
          navigator.serviceWorker.register('/service-worker.js')
            .then(function(reg) { console.log('Service Worker registrado!', reg); })
            .catch(function(err) { console.log('Erro ao registrar Service Worker:', err); });
        });
      }

      // Atualiza todas as thumbs ao mudar qualquer filtro
      document.getElementById('daidoMoriyama').addEventListener('change', updateAllThumbs);
      document.getElementById('leicaBW').addEventListener('change', updateAllThumbs);
      document.getElementById('ultraDaido').addEventListener('change', updateAllThumbs);
      document.getElementById('leicaQ3Color').addEventListener('change', updateAllThumbs);
      function updateAllThumbs() {
        const daidoAtivo = document.getElementById('daidoMoriyama')?.checked;
        const leicaAtivo = document.getElementById('leicaBW')?.checked;
        const ultraDaidoAtivo = document.getElementById('ultraDaido')?.checked;
        const leicaQ3ColorAtivo = document.getElementById('leicaQ3Color')?.checked;
        const thumbs = document.querySelectorAll('#thumbsGrid canvas');
        thumbs.forEach((canvas, idx) => {
          const ctx = canvas.getContext('2d');
          const img = new Image();
          img.onload = function() {
            renderThumb(img, canvas, leicaAtivo, daidoAtivo, ultraDaidoAtivo, leicaQ3ColorAtivo);
          };
          img.src = window._thumbSources[idx];
        });
      }
    </script>
  </body>
</html>
